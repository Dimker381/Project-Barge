# Project-Barge

Клешнин Дмитрий Владиславович ИТ-7 

Вариант 11

Баржа с K отсеками проплывает через N доков, в которых происходят операции погрузки и выгрузки бочек с разным топливом. Требуется проверить корректность операций и найти максимум одновременно находившихся на борту бочек.


Код в master


Разъяснение кода:

Обработка исключений и ООП в программе:

1. Где и почему используется обработка ошибок:
В программе не используются стандартные классы исключений Python (try-except), а реализована внутренняя обработка ошибок вручную через флаги self.error и self.error_message.

Почему так сделано:
Производительность: не создаются объекты исключений при каждом нарушении.
Контроль: вся логика ошибок сосредоточена в классе Barge, а не разбросана по разным try-except блокам.
Требование задачи: по условию нужно зафиксировать ошибку в логике операции, а не техническую ошибку выполнения кода.

Исключения (try-except) всё же используются:
При чтении и преобразовании входных данных (например, преобразование int(), количество аргументов и т.д.) в функции main().

2. Классы и объектно-ориентированные принципы:
Node — простой узел связного списка:
Хранит значение и ссылку на следующий элемент.
Нужен для реализации стека без использования list.

Stack — собственная структура данных:
Реализует поведение стека (LIFO) через Node.
Используется вместо списка в каждом отсеке баржи.
Упрощает управление и повышает читаемость, код легче тестировать и расширять.

Barge — модель всей баржи:
Содержит список отсеков (каждый — Stack).
Хранит общее количество бочек, максимум, ошибки.
Отвечает за бизнес-логику: погрузка, выгрузка, проверка операций.

3. Инкапсуляция:
Переменные состояния (compartments, total_barrels, error, max_barrels, error_message) скрыты внутри класса Barge.
Доступ к этим данным осуществляется только через методы load(), unload(), process(), is_empty().

Все внутренние данные (top_node, size, compartments, total_barrels, error_message) скрыты в соответствующих классах.
Пользователь работает только через методы (push, pop, load, unload, process), не обращаясь напрямую к структуре данных.

4. Наследование:
В текущей версии — не используется, так как проект небольшой и все классы имеют разные назначения.

5. Полиморфизм:
Прямого полиморфизма через наследование в коде нет.
Но косвенно применяется поведенческий полиморфизм через метод process():
Метод обрабатывает строки вида + A B или - A B и вызывает соответствующее поведение.
Один метод — разные действия (погрузка или выгрузка) в зависимости от входа.
